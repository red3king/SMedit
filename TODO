RIGHT NOW:

x RESOURCE LOCK SERVER IMPLEMENTATION!!!
x    done!

    
xjust added code scan notifications
x    they scan for get_resource() calls and notify if you aren't in a lock
x        working!
x    i need to add a new type of notification - for when you get_resource on something
x        which isn't even defined
x        
x        should I implement it as i have been doing for the first 2 types of notificataion?
x            or implement a system which streamlines some of the common parts of the code between all 3??
x               (this would go into the gui model base class)
                

x    - custom state class implementation
x    - my load from custom state def file code works
x    - now i need to:
x        - test creation of custom states!
x            LEFT OFF HERE, CRASH ON TYPE CHANGE -> CUSTOM TYPE
x            VARIABLES ARE "OPTIMIZED OUT" EVEN WHEN I COMPILED WITH -O0! WTF
:
x        - test all new operations, all changed operations, all controller buttons
x        - I think I have written all the code for the client ?? server is next!
LOH            - nevermind, there is still GUIModel stuff (highlight invalid state)
                    invalid state? what does that mean?

    
x    - implement CustomStateDef class
    
x    - DONT DO THIS, USE ALTERNATIVE B on save, write current state def list to project.json
    
x    - on load, scan all resources and compare that list to project.json
x        - fire signal
x        - this does not go in the undo system because it happens before the user can do anything

x    - two alternatives:
        - don't persist any custom state def (other than uuid) into the project.json:
            at load, always read each cust state def into our c objects
            This could be a problem because the user may be confused if somebody else changed the files when they weren't paying attention
                this is a small issue though
                
x        - do persist this data
x            at load, read the data but ask the user what to do if there is any difference
x            this way, the user will know if something went wrong
    
    UI STUFF
        - on_custom_state_def_changed():
            - when a user sets the custom state python file path,
                the code which reads the custom state file and updates the custom state's def
                should live in on Operation, so the data will be correct if the user ctrl-z's before 
                the custom state was created and the redoes until after the state def path was set
                
            - update gui, which will cause the gui models of states using this custom state type
                to possibly go invalid with error message about changed state specs

    model changes
x        add custom state class model
        modify state + transition model? (may need to change to support cscs, eg add is_custom_state() function)
 
    gui op / normal op changes
x        - add custom state class operations
x        - modify state delete operation so it deletes mandatory transitions
x        - modify state type change operation so it creates/deletes transitions as well
        - modify transition operations:
x            - can't move one endpoint of cust state transitions
xad            - can't drag-move any cust state transition (probably already true since one end is always connected)
x           - can't delete cust state transitions (not part of operation, part of gui or the operation factory)
x           - can't select cust state transitions ? (should they be editable? or just always perscribed?)
x                let's start with making them unmodifiiable
x            - can't attach outgoing normal transitions to custom state types (can attach incomin ofc)
x                this could be changed in the future?

x        - when user tries to delete:
x            ask for confirmation
x            then also delete all instances of this custom state and their transitions
        
    project load stuff
x        reset list of registered custom state clases? (if this data isn't stored in a Proejct object)
x        modify saveload to handle custom state classes
        
x    net stuff
x        modify project upload to also upload the custom state classes
        

                
x custom state type integration - SERVER
x    modify project load code to exec all custom state files, and register resulting classes in some dict,    "StateClasses" or soemthing


resourcelock implementation

    in each state, you pick form a list which resources you want to use
    they are then put into the auto-generated function def line
    if you pick a resource that needs a lock, display error icon over state until its in a reousrclock
    
    features - client:
x        - display error icons with hover texts on state objects
            (make extsible enough so i could put them on transitions too later)
        - state used_resources list:
            - add to model
            - add operations to change
            - add checkboxlist to code state edit gui
        - resource deletion:
            - count resourcelocks, resources referring to it, 
                and pop up confirmation dialog
            - if user says yes, delete those resourcelocks, and modify states referring to it
        - requires_lock scan:
            - on program load, on resource filename change, possibly if user requests it w/button
            - this will set Resource.requires_lock to YES, NO, or UNKNOWN
                - should trigger the gui to update accordingly

    features - server:
        - project.on_machine_lock_release()
            - if any machines waiting for this lock, take first, remove from list, "give it the lock", and..
            - call (new method) machine.notify_lock_available():
                - this calls RunNextStateSrop.notify_lock_available() (runnextstatesrop or its subclass can be the only srop you have when you are waiting for a lock.)
                - notify_lock_available() works just like JoniSROP.notify_machine_finished(), it 
                    calls srop_if_next() and runs that.

        - when a lock is released, the server looks at the list ofo "i need lock" machines,
            and gives it to the first one in the list ( one list per lock type ofc)

        - modify state change srop:
            - if lock is needed that we don't have:  
                - call machine.acquire_lock signal
                    acquire_lock returns true (project has given you the lock, ok):
                        continue as usual

                    acquire_lock returns false (another machine has the lock, this machine is added to a list of machines waiting for the lock):
                        don't do anything, don't go to next srop or state. (behave like joinSROP)
            
            - if lock is have that we don't need: fire machine.release_lock(...) signal for the unneeded resource
        



todo 
    - change all paths to relative (rn my csc path is /home/rory/..../csc.py)
    - make the custom state class and resource file choosers start in the currrent proj directory
    
    - implement the local and server options:
        - enable/disable autopan
        - minimum state transition time on server 


at some point, find a way to catch errors in the functions sent into the twisted event loop, 
    and display those on the client.



undoing and then redoing the same thing seems buggy, after a while there's no more undo/redo at all


bug
    make a 2x wider state and a normal size one
    connect the 2 states
    zoom out a bunch (may not be necessary)
    rotate the smamll one around the big one
        the transition doesnt always stay stuck to both, it disconnects from the small one sometimes.


box entity stuff
    then do the double resize operation (corner drag)
    then possibly refactor the move state/rlock ops into a single move box entity operation to be consistent
    
    fix drawing order to be same as click event handling order
        (resourcelocks last, either states or transitions first, i think transitions?)
 

=== for later === 

CHECK - that all object modifications are done by submitting operations and i didnt accidentally write direct modification that will mess up the history system`:

add error checks to everything that could fail:
    opengl init
    font load
    ... check nanovg examples for all error codes that they check

when done, test to see if things get screwed up if a gui operation is in progress (eg, dragging a state), and you drag away from the gl area, release the mb, and then come back. presumably it would enter a weird state and you would have to click and release once more to release the state.

if GuiOpResult.CANCEL is going to be a thing, then whene it's returned, we may need to silently undo the last operation? figure out how that's gonna work, if cancel is to be a thing. could be used when you drag a state off the 

enforce no undo / redo while there is a gui operation
    so gui operations with pointers to "current whatever" wont break because user pressedd ctrl z 

