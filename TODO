right now - better machine termination rendering
    currently, when a machine finishes, the ui immediatly removes it
    it should be kept around for long enough for the auto pan to its terminal state to finish, 
        and the word "finished" should be displayed on the screen


now
    machine finishes
    RunningState::on_machine_deleted() immediately fires its machine_selected
    
plan
    machine finishes
    RunningState::on_machine_deleted() begins a timer
    timer elapsed -> fire machine_selected
    
    if a second machine is deleted when the timer is running,
        immediately fire machine_selected to go to second deleted machine,
        then set the timer up again.

BIG TICKET ITEMS
    state synch on connect
    custom state types w/ premade unmodifiiable transitions
    resource implementation
    resourcelock implementaiton
    

todo - implement the local and server options:
    - enable/disable autopan
    - minimum state transition time on server 


animations:
    also, when the last transition occurs, i might want the machine to stick around so the user can see the full
        transition into the final state. maybe thats better than trying to build that complicated call stack i wanted.
        (the user will still be able to use the machine list piker to choose a machine)

    next up: do that machine list picker


at some point, find a way to catch errors in the functions sent into the twisted event loop, 
    and display those on the client.


eventually, build the get current running project status command,
    which will sync up the current:
        -list of running machines and their states
        -whether or not the current project is paused, started or stopped
    this should happen before we can render, after we get a hash match, on connect.


then: add in custom state types & implement http and file io states.


undoing and then redoing the same thing seems buggy, after a while there's no more undo/redo at all


bug
    make a 2x wider state and a normal size one
    connect the 2 states
    zoom out a bunch (may not be necessary)
    rotate the smamll one around the big one
        the transition doesnt always stay stuck to both, it disconnects from the small one sometimes.


box entity stuff
    then do the double resize operation (corner drag)
    then possibly refactor the move state/rlock ops into a single move box entity operation to be consistent
    
    fix drawing order to be same as click event handling order
        (resourcelocks last, either states or transitions first, i think transitions?)
 

=== for later === 

CHECK - that all object modifications are done by submitting operations and i didnt accidentally write direct modification that will mess up the history system`:

add error checks to everything that could fail:
    opengl init
    font load
    ... check nanovg examples for all error codes that they check

when done, test to see if things get screwed up if a gui operation is in progress (eg, dragging a state), and you drag away from the gl area, release the mb, and then come back. presumably it would enter a weird state and you would have to click and release once more to release the state.

if GuiOpResult.CANCEL is going to be a thing, then whene it's returned, we may need to silently undo the last operation? figure out how that's gonna work, if cancel is to be a thing. could be used when you drag a state off the 

enforce no undo / redo while there is a gui operation
    so gui operations with pointers to "current whatever" wont break because user pressedd ctrl z 

