resourcelock implementation

    in each state, you pick form a list which resources you want to use
    they are then put into the auto-generated function def line
    if you pick a resource that needs a lock, display error icon over state until its in a reousrclock
    
    features - client:
        - display error icons with hover texts on state objects
            (make extsible enough so i could put them on transitions too later)
        - state used_resources list:
            - add to model
            - add operations to change
            - add checkboxlist to code state edit gui
        - resource deletion:
            - count resourcelocks, resources referring to it, 
                and pop up confirmation dialog
            - if user says yes, delete those resourcelocks, and modify states referring to it
        - requires_lock scan:
            - on program load, on resource filename change, possibly if user requests it w/button
            - this will set Resource.requires_lock to YES, NO, or UNKNOWN
                - should trigger the gui to update accordingly

    features - server:
        - project.on_machine_lock_release()
            - if any machines waiting for this lock, take first, remove from list, "give it the lock", and..
            - call (new method) machine.notify_lock_available():
                - this calls RunNextStateSrop.notify_lock_available() (runnextstatesrop or its subclass can be the only srop you have when you are waiting for a lock.)
                - notify_lock_available() works just like JoniSROP.notify_machine_finished(), it 
                    calls srop_if_next() and runs that.

        - when a lock is released, the server looks at the list ofo "i need lock" machines,
            and gives it to the first one in the list ( one list per lock type ofc)

        - modify state change srop:
            - if lock is needed that we don't have:  
                - call machine.acquire_lock signal
                    acquire_lock returns true (project has given you the lock, ok):
                        continue as usual

                    acquire_lock returns false (another machine has the lock, this machine is added to a list of machines waiting for the lock):
                        don't do anything, don't go to next srop or state. (behave like joinSROP)
            
            - if lock is have that we don't need: fire machine.release_lock(...) signal for the unneeded resource
        


BIG TICKET ITEMS
    custom state types w/ premade unmodifiiable transitions
    

todo - implement the local and server options:
    - enable/disable autopan
    - minimum state transition time on server 


at some point, find a way to catch errors in the functions sent into the twisted event loop, 
    and display those on the client.



undoing and then redoing the same thing seems buggy, after a while there's no more undo/redo at all


bug
    make a 2x wider state and a normal size one
    connect the 2 states
    zoom out a bunch (may not be necessary)
    rotate the smamll one around the big one
        the transition doesnt always stay stuck to both, it disconnects from the small one sometimes.


box entity stuff
    then do the double resize operation (corner drag)
    then possibly refactor the move state/rlock ops into a single move box entity operation to be consistent
    
    fix drawing order to be same as click event handling order
        (resourcelocks last, either states or transitions first, i think transitions?)
 

=== for later === 

CHECK - that all object modifications are done by submitting operations and i didnt accidentally write direct modification that will mess up the history system`:

add error checks to everything that could fail:
    opengl init
    font load
    ... check nanovg examples for all error codes that they check

when done, test to see if things get screwed up if a gui operation is in progress (eg, dragging a state), and you drag away from the gl area, release the mb, and then come back. presumably it would enter a weird state and you would have to click and release once more to release the state.

if GuiOpResult.CANCEL is going to be a thing, then whene it's returned, we may need to silently undo the last operation? figure out how that's gonna work, if cancel is to be a thing. could be used when you drag a state off the 

enforce no undo / redo while there is a gui operation
    so gui operations with pointers to "current whatever" wont break because user pressedd ctrl z 

