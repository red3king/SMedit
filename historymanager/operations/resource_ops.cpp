#include "resource_ops.h"
#include "signals.h"


// Abstract change

ResourceChgOperation::ResourceChgOperation(Resource* resource)
{
    resource_id = resource->id;
}


unsigned int ResourceChgOperation::execute(Project& project)
{
    Resource* resource = project.get_resource_by_id(resource_id);
    execute_impl(resource);
    signals.fire_model_changed(RESOURCE, MODIFY, resource_id);
    return resource_id;
}


// Create

OpResourceCreate::OpResourceCreate(string name, string path)
{
    this->name = name;
    this->path = path;
}


unsigned int OpResourceCreate::execute(Project& project)
{
    Resource* resource = new Resource(project.get_next_id());
    resource->name = name;
    resource->path = path;
    project.resources.push_back(resource);
    
    signals.fire_model_changed(RESOURCE, CREATE, resource->id);
    return resource->id;
}


OpResourceCreate* OpResourceCreate::clone()
{
    return new OpResourceCreate(*this);
}


// Delete

OpResourceDelete::OpResourceDelete(Resource* to_delete)
{
    to_delete_id = to_delete->id;
}


bool delete_next_resourcelock(vector<ResourceLock*>& resourcelocks, unsigned int resource_id)
{
    for(int i=0; i<resourcelocks.size(); i++)
    {
        ResourceLock* lock = resourcelocks[i];
        if(lock->resource->id == resource_id)
        {
            signals.fire_model_changed(RESOURCELOCK, PRE_DELETE, lock->id);
            delete lock;
            resourcelocks.erase(resourcelocks.begin() + i);
            return true;
        }
    }
    return false;
}


unsigned int OpResourceDelete::execute(Project& project)
{
    int rindex = project.get_rindex_by_id(to_delete_id);

    // delete all resourcelocks using this first (user has confirmed)
    for(int i=0; i<project.machines.size(); i++)
    {
        Machine* machine = project.machines[i];
        while(delete_next_resourcelock(machine->resourcelocks, to_delete_id));
    }

    signals.fire_model_changed(RESOURCE, PRE_DELETE, to_delete_id);

    delete project.resources[rindex];
    project.resources.erase(project.resources.begin() + rindex);
    return to_delete_id;
}


OpResourceDelete* OpResourceDelete::clone()
{
    return new OpResourceDelete(*this);
}


// MACHINE GENERATED CODE BELOW, DO NOT EDIT
// USE COG TO REGENERATE

/*[[[cog

import os
import sys
sys.path.append(os.getcwd())
from codegen.op_specs import *

for line in resource_opgen.make_cpp():
    cog.outl(line)

]]]*/


// path  -  AUTOGENERATED, DO NOT MODIFY

OpResourcePath::OpResourcePath(Resource* resource, string path) : ResourceChgOperation(resource)
{
    this->path = path;
}


OpResourcePath* OpResourcePath::clone()
{
    return new OpResourcePath(*this);
}


void OpResourcePath::execute_impl(Resource* resource)
{
    resource->path = path;
}


bool OpResourcePath::may_collapse_impl(Operation& other)
{
    auto op = (OpResourcePath&) other;
    return resource_id == op.resource_id;
}


void OpResourcePath::collapse(Operation& other)
{
    auto op = (OpResourcePath&) other;
    path = op.path;
}


// name  -  AUTOGENERATED, DO NOT MODIFY

OpResourceName::OpResourceName(Resource* resource, string name) : ResourceChgOperation(resource)
{
    this->name = name;
}


OpResourceName* OpResourceName::clone()
{
    return new OpResourceName(*this);
}


void OpResourceName::execute_impl(Resource* resource)
{
    resource->name = name;
}


bool OpResourceName::may_collapse_impl(Operation& other)
{
    auto op = (OpResourceName&) other;
    return resource_id == op.resource_id;
}


void OpResourceName::collapse(Operation& other)
{
    auto op = (OpResourceName&) other;
    name = op.name;
}


//[[[end]]]

